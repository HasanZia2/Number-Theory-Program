# -*- coding: utf-8 -*-
"""
Created on Sat Jan  4 23:49:28 2025

@author: hzia2
"""

def EuclideanAlgorithm(initial_number1, initial_number2):
    # This function reworks the Euclidean Algorithm program. It uses the same
    # code without the print statements, and returns a list of values which may
    # be used by other functions.
    
    number1 = initial_number1
    number2 = initial_number2
    remainder = number1%number2
    step = -1
    quotients = []
    number1s = []

    while remainder >= 0:
        quotient = number1//number2
        if abs(number1) >= abs(number2):
            number1s.append(number1)
            quotients.append(quotient)
            step += 1
        remainder = number1%number2
        try:
            number2%remainder
            if number2%remainder == 0 and step != -1:
                break
            else:
                number1 = number2
                number2 = remainder
        except ZeroDivisionError:
            if not initial_number1%initial_number2 == 0 or not initial_number2%initial_number1 == 0 or initial_number1 == initial_number2:
                if initial_number1 > initial_number2:
                    remainder = initial_number2
                else:
                    remainder = initial_number1    
            break
    
    final_number2 = number2
    
    step_after_gcd = step
    steps = range(step, -1, -1)
    coefficient1 = 1
    if step == 0 and initial_number1%initial_number2 == 0 or initial_number2%initial_number1 == 0:
        coefficient2 = 1
    else:
        coefficient2 = 0
    for step in steps:
        if (step_after_gcd - step)%2 != 0:
            coefficient1 += abs(coefficient2)*quotients[step]
            number2 = number1s[step]
        elif (step_after_gcd - step)%2 == 0: 
            if step_after_gcd - step != 0:
                number1 = number1s[step]
            coefficient2 -= abs(coefficient1)*quotients[step]
    
    if abs(initial_number1) >= abs(initial_number2):
        continued_fraction = quotients
    else:
        continued_fraction = [0] + quotients
    if initial_number1 != initial_number2:
        continued_fraction.append(int(final_number2/remainder))
    continued_fraction = str(continued_fraction).replace(",", ";", 1)
    
    return [remainder, coefficient1, number1, coefficient2, number2, continued_fraction]

def PrimitivePythagoreanTriple():
    # This function finds the primitive Pythagorean triple associated with
    # the inputted values of the integers u and v.
    
    print("This program generates a primitive Pythagorean triple given two positive integers u and v that satisfy u > v ∧ gcd(u, v) = 1 ∧ u ≢ v (mod 2). ")
    print(" ")
    u = int(input("Enter the value of u. "))
    while u <= 0:
        u = int(input("Your input for u was not a positive integer. Please try again. "))
    v = int(input("Enter the value of v. "))
    while v <= 0 or v >= u or EuclideanAlgorithm(u, v)[0] != 1 or (u%2 == 0 and v%2 == 0) or (u%2 == 1 and v%2 == 1):
        print(" ")
        print("Your input for v is invalid for the following reasons:")
        print(" ")
        if v <= 0:
            print("Your input for v was not a positive integer. ")
        if v >= u:
            print("Your input for v was not less than your input for u. ")
        if EuclideanAlgorithm(u, v)[0] != 1:
            print("Your input for v was not coprime with your input for u. ")
        if (u%2 == 0 and v%2 == 0) or (u%2 == 1 and v%2 == 1):
            print("Your inputs for u and v do not satisfy u ≢ v (mod 2). ")
        print(" ")
        v = int(input("Please enter a new value for v. "))
        
    x = u**2 - v**2
    y = 2*u*v
    z = u**2 + v**2
    
    print(" ")
    print("The primitive Pythagorean triple generated by u = " + str(u) + " and v = " + str(v) + " is (" + str(x) + ", " + str(y) + ", " + str(z) + "). ")

def main():
    PrimitivePythagoreanTriple()

if __name__ == '__main__':
    main()